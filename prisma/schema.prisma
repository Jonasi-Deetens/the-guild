// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts  Account[]
  sessions  Session[]
  character Character?
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Character {
  id         String @id @default(cuid())
  name       String @unique
  level      Int    @default(1)
  experience Int    @default(0)
  gold       Int    @default(100)
  reputation Int    @default(0) // -100 to 100, affects NPC prices and player trust
  health     Int    @default(100)
  maxHealth  Int    @default(100)
  attack     Int    @default(10)
  defense    Int    @default(5)
  speed      Int    @default(5)
  perception Int    @default(5) // affects theft detection

  // New RPG combat stats
  agility        Int   @default(5) // Affects parry window
  criticalChance Float @default(0.05) // 5% base crit chance
  blockStrength  Int   @default(3) // Damage reduction when blocking

  // Combat state (for dungeon sessions)
  currentHealth Int? // Tracks health during active dungeon

  isOnline  Boolean  @default(false)
  lastSeen  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Character can be in one party at a time
  partyId String?
  party   Party?  @relation("PartyMembers", fields: [partyId], references: [id])

  // Character's inventory
  inventory Inventory[]

  // Character's transactions (as actor)
  transactions Transaction[] @relation("TransactionActor")

  // Character's transactions (as target)
  targetTransactions Transaction[] @relation("TransactionTarget")

  // Character's dungeon turns
  dungeonTurns DungeonTurn[]

  // Character's party memberships
  partyMembers PartyMember[]

  // Character's party leadership
  ledParties Party[] @relation("PartyLeader")

  // Trading relations
  tradeRequestsSent     TradeRequest[] @relation("TradeRequestFrom")
  tradeRequestsReceived TradeRequest[] @relation("TradeRequestTo")

  // Bounty relations
  bountiesPlaced Bounty[] @relation("BountyPlacedBy")
  bountiesTarget Bounty[] @relation("BountyTarget")

  // Report relations
  reportsMade    Report[] @relation("ReportReporter")
  reportsAgainst Report[] @relation("ReportReported")

  // Dungeon event actions
  dungeonActions DungeonPlayerAction[]

  // Statistics
  statistics CharacterStatistics?

  @@index([isOnline])
  @@index([reputation])
  @@index([gold])
}

model Mission {
  id               String   @id @default(cuid())
  name             String
  description      String
  difficulty       Int // 1-5 scale
  minLevel         Int      @default(1)
  maxPlayers       Int      @default(5)
  minPlayers       Int      @default(2)
  baseReward       Int // base gold reward
  experienceReward Int      @default(10)
  isActive         Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  dungeonSessions DungeonSession[]
}

model Party {
  id         String      @id @default(cuid())
  name       String?
  isPublic   Boolean     @default(false)
  maxMembers Int         @default(5)
  status     PartyStatus @default(FORMING)
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt

  // Relations
  leaderId        String
  leader          Character        @relation("PartyLeader", fields: [leaderId], references: [id])
  members         PartyMember[]
  characters      Character[]      @relation("PartyMembers")
  dungeonSessions DungeonSession[]
}

model PartyMember {
  id       String   @id @default(cuid())
  role     String? // "tank", "dps", "healer", "support"
  isReady  Boolean  @default(false)
  joinedAt DateTime @default(now())

  // Relations
  partyId     String
  party       Party     @relation(fields: [partyId], references: [id], onDelete: Cascade)
  characterId String
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  @@unique([partyId, characterId])
}

model DungeonSession {
  id            String        @id @default(cuid())
  status        DungeonStatus @default(WAITING)
  currentTurn   Int           @default(0)
  maxTurns      Int           @default(10)
  turnTimeLimit Int           @default(60) // seconds per turn
  turnEndsAt    DateTime?
  startedAt     DateTime?
  completedAt   DateTime?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // New event-based fields
  currentEventId String?
  timeline       Json? // Graph structure of events
  seed           String? // For reproducible proc-gen

  // Relations
  missionId String
  mission   Mission @relation(fields: [missionId], references: [id])
  partyId   String?
  party     Party?  @relation(fields: [partyId], references: [id])

  turns      DungeonTurn[]
  loot       DungeonLoot[]
  events     DungeonEvent[]
  statistics DungeonStatistics?
}

model DungeonTurn {
  id          String        @id @default(cuid())
  turnNumber  Int
  action      DungeonAction
  targetId    String? // for targeted actions
  itemId      String? // for item usage
  damage      Int? // calculated damage dealt
  healing     Int? // calculated healing done
  isResolved  Boolean       @default(false)
  submittedAt DateTime      @default(now())
  resolvedAt  DateTime?

  // Relations
  sessionId   String
  session     DungeonSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  characterId String
  character   Character      @relation(fields: [characterId], references: [id])

  @@unique([sessionId, characterId, turnNumber])
}

model DungeonLoot {
  id        String    @id @default(cuid())
  itemId    String
  quantity  Int       @default(1)
  claimedBy String? // characterId who claimed it
  claimedAt DateTime?
  createdAt DateTime  @default(now())

  // Relations
  sessionId String
  session   DungeonSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  item      Item           @relation(fields: [itemId], references: [id])
}

model Item {
  id          String     @id @default(cuid())
  name        String
  description String
  type        ItemType
  rarity      ItemRarity @default(COMMON)
  value       Int // gold value
  attack      Int? // weapon stats
  defense     Int? // armor stats
  healing     Int? // consumable healing amount
  isTradeable Boolean    @default(true)
  isStackable Boolean    @default(false)
  maxStack    Int        @default(1)
  createdAt   DateTime   @default(now())

  // Relations
  inventory   Inventory[]
  dungeonLoot DungeonLoot[]
  Transaction Transaction[]
}

model Inventory {
  id        String   @id @default(cuid())
  quantity  Int      @default(1)
  equipped  Boolean  @default(false)
  createdAt DateTime @default(now())

  // Relations
  characterId String
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  itemId      String
  item        Item      @relation(fields: [itemId], references: [id])

  @@unique([characterId, itemId])
}

model Transaction {
  id           String          @id @default(cuid())
  type         TransactionType
  amount       Int? // gold amount for trades/thefts
  description  String
  metadata     Json? // additional data for complex transactions
  isSuccessful Boolean         @default(true)
  createdAt    DateTime        @default(now())

  // Relations
  actorId  String
  actor    Character  @relation("TransactionActor", fields: [actorId], references: [id])
  targetId String?
  target   Character? @relation("TransactionTarget", fields: [targetId], references: [id])
  itemId   String?
  item     Item?      @relation(fields: [itemId], references: [id])

  @@index([actorId])
  @@index([targetId])
  @@index([type])
  @@index([createdAt])
}

model TradeRequest {
  id             String      @id @default(cuid())
  status         TradeStatus @default(PENDING)
  offeredItems   Json // Array of {itemId, quantity}
  offeredGold    Int         @default(0)
  requestedItems Json // Array of {itemId, quantity}
  requestedGold  Int         @default(0)
  message        String?
  createdAt      DateTime    @default(now())
  acceptedAt     DateTime?
  completedAt    DateTime?

  // Relations
  fromCharacterId String
  fromCharacter   Character @relation("TradeRequestFrom", fields: [fromCharacterId], references: [id])
  toCharacterId   String
  toCharacter     Character @relation("TradeRequestTo", fields: [toCharacterId], references: [id])

  @@index([fromCharacterId])
  @@index([toCharacterId])
  @@index([status])
}

model Bounty {
  id        String       @id @default(cuid())
  amount    Int
  reason    String?
  status    BountyStatus @default(ACTIVE)
  createdAt DateTime     @default(now())
  claimedAt DateTime?
  claimedBy String? // characterId who claimed it

  // Relations
  placedBy          String
  placedByCharacter Character @relation("BountyPlacedBy", fields: [placedBy], references: [id])
  targetId          String
  targetCharacter   Character @relation("BountyTarget", fields: [targetId], references: [id])

  @@index([status])
  @@index([amount])
}

model Report {
  id          String       @id @default(cuid())
  reason      ReportReason
  description String
  status      ReportStatus @default(PENDING)
  createdAt   DateTime     @default(now())
  resolvedAt  DateTime?
  resolvedBy  String? // admin user ID

  // Relations
  reporterId String
  reporter   Character @relation("ReportReporter", fields: [reporterId], references: [id])
  reportedId String
  reported   Character @relation("ReportReported", fields: [reportedId], references: [id])

  @@index([status])
  @@index([reporterId])
  @@index([reportedId])
}

// Enums
enum PartyStatus {
  FORMING
  READY
  IN_DUNGEON
  COMPLETED
  DISBANDED
}

enum DungeonStatus {
  WAITING
  ACTIVE
  COMPLETED
  FAILED
  ABANDONED
}

enum DungeonAction {
  ATTACK
  DEFEND
  USE_ITEM
  FLEE
  BETRAY
  WAIT
}

enum ItemType {
  WEAPON
  ARMOR
  CONSUMABLE
  MISC
}

enum ItemRarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
}

model DungeonStatistics {
  id        String         @id @default(cuid())
  sessionId String         @unique
  session   DungeonSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Overall stats
  totalEvents     Int @default(0)
  completedEvents Int @default(0)
  failedEvents    Int @default(0)
  totalTimeSpent  Int @default(0) // in seconds

  // Combat stats
  enemiesDefeated Int @default(0)
  damageDealt     Int @default(0)
  damageTaken     Int @default(0)
  timesFled       Int @default(0)

  // Treasure stats
  goldEarned   Int @default(0)
  itemsFound   Int @default(0)
  chestsOpened Int @default(0)

  // Experience stats
  experienceGained Int @default(0)
  levelsGained     Int @default(0)

  // Event type breakdown
  combatEvents   Int @default(0)
  treasureEvents Int @default(0)
  trapEvents     Int @default(0)
  puzzleEvents   Int @default(0)
  choiceEvents   Int @default(0)
  restEvents     Int @default(0)
  bossEvents     Int @default(0)

  // Performance metrics
  averageEventTime Int   @default(0) // average seconds per event
  successRate      Float @default(0) // percentage of successful events
  efficiency       Float @default(0) // gold/XP per minute

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model CharacterStatistics {
  id          String    @id @default(cuid())
  characterId String    @unique
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  // Lifetime stats
  totalDungeonsCompleted Int @default(0)
  totalDungeonsFailed    Int @default(0)
  totalTimeSpent         Int @default(0) // in seconds
  totalGoldEarned        Int @default(0)
  totalExperienceGained  Int @default(0)
  totalLevelsGained      Int @default(0)

  // Combat lifetime stats
  totalEnemiesDefeated Int @default(0)
  totalDamageDealt     Int @default(0)
  totalDamageTaken     Int @default(0)
  totalTimesFled       Int @default(0)

  // Item stats
  totalItemsFound   Int @default(0)
  totalChestsOpened Int @default(0)
  totalItemsUsed    Int @default(0)

  // Performance metrics
  averageDungeonTime    Int   @default(0)
  successRate           Float @default(0)
  averageGoldPerDungeon Int   @default(0)
  averageXPPerDungeon   Int   @default(0)

  // Records
  longestDungeonTime   Int @default(0)
  mostGoldInDungeon    Int @default(0)
  mostXPInDungeon      Int @default(0)
  mostEnemiesInDungeon Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum TransactionType {
  TRADE
  THEFT
  KILL
  MISSION_REWARD
  SHOP_PURCHASE
  SHOP_SALE
  GIFT
  BOUNTY_PAYMENT
  BOUNTY_PLACED
  BOUNTY_CLAIMED
  DUNGEON_LOOT
}

enum TradeStatus {
  PENDING
  ACCEPTED
  REJECTED
  COMPLETED
  CANCELLED
}

enum BountyStatus {
  ACTIVE
  CLAIMED
  EXPIRED
  CANCELLED
}

enum ReportReason {
  CHEATING
  HARASSMENT
  EXPLOIT
  OTHER
}

enum ReportStatus {
  PENDING
  INVESTIGATING
  RESOLVED
  DISMISSED
}

// New Event System Models
model EventTemplate {
  id           String        @id @default(cuid())
  type         EventType
  name         String
  description  String
  difficulty   Int // 1-5
  minigameType MinigameType?
  config       Json // Event-specific configuration
  outcomes     Json // Possible outcomes and branches
  createdAt    DateTime      @default(now())

  dungeonEvents DungeonEvent[]
}

model DungeonEvent {
  id        String         @id @default(cuid())
  sessionId String
  session   DungeonSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  templateId String?
  template   EventTemplate? @relation(fields: [templateId], references: [id])

  eventNumber   Int // Position in timeline
  parentEventId String? // For branching
  parentEvent   DungeonEvent?  @relation("EventBranches", fields: [parentEventId], references: [id])
  childEvents   DungeonEvent[] @relation("EventBranches")

  status    EventStatus @default(PENDING)
  eventData Json // Current state, enemy stats, etc.
  results   Json? // Outcome data

  startsAt    DateTime?
  completedAt DateTime?
  createdAt   DateTime  @default(now())

  playerActions DungeonPlayerAction[]

  @@index([sessionId, eventNumber])
  @@index([parentEventId])
}

model DungeonPlayerAction {
  id          String       @id @default(cuid())
  eventId     String
  event       DungeonEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  characterId String
  character   Character    @relation(fields: [characterId], references: [id])

  actionType  String // Event-specific action
  actionData  Json // Action parameters
  result      Json? // Calculated result
  submittedAt DateTime @default(now())

  @@unique([eventId, characterId])
  @@index([characterId])
}

enum EventType {
  COMBAT
  TREASURE
  TRAP
  PUZZLE
  CHOICE
  REST
  BOSS
  BETRAYAL_OPPORTUNITY
  NPC_ENCOUNTER
  ENVIRONMENTAL_HAZARD
}

enum MinigameType {
  JUMPING_GAPS // Canvas-based platformer
  CLOSING_WALLS // Timing game
  LOCK_PICKING // Pattern matching
  RIDDLE // Text-based
  QUICK_TIME // Reaction test
  COMBAT_CLICKER // Cookie-clicker style combat
  NONE
}

enum EventStatus {
  PENDING // Not yet reached
  ACTIVE // Currently happening
  WAITING // Waiting for players
  RESOLVING // Processing results
  COMPLETED // Finished
  SKIPPED // Bypassed via branching
}

// Monster System Models
model MonsterTemplate {
  id          String      @id @default(cuid())
  name        String      @unique
  type        MonsterType
  baseHealth  Int
  baseAttack  Int
  baseDefense Int
  attackSpeed Float       @default(1.0) // Multiplier for attack interval

  // Special properties
  canBeElite Boolean @default(true)
  abilities  Json? // Special abilities (healing, AOE, etc.)

  rarity      MonsterRarity @default(COMMON)
  description String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum MonsterType {
  WARRIOR // High defense, moderate attack
  RANGER // Balanced stats, faster attacks
  MAGE // Low defense, high attack
  HEALER // Low attack, can heal other monsters
  TANK // Very high defense, low attack
  BERSERKER // High attack, low defense
}

enum MonsterRarity {
  COMMON
  ELITE // 1.5x stats
  RARE // 2x stats, special abilities
  BOSS // 3x stats, multiple abilities
}

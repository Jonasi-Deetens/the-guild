generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String     @id @default(cuid())
  name          String?
  email         String     @unique
  emailVerified DateTime?
  image         String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  accounts      Account[]
  character     Character?
  sessions      Session[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Character {
  id                    String                @id @default(cuid())
  name                  String                @unique
  level                 Int                   @default(1)
  experience            Int                   @default(0)
  gold                  Int                   @default(100)
  reputation            Int                   @default(0)
  currentHealth         Int                   @default(100)
  maxHealth             Int                   @default(100)
  attack                Int                   @default(10)
  defense               Int                   @default(5)
  speed                 Int                   @default(5)
  perception            Int                   @default(5)
  isOnline              Boolean               @default(false)
  lastSeen              DateTime              @default(now())
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  userId                String                @unique
  partyId               String?
  agility               Int                   @default(5)
  blockStrength         Int                   @default(3)
  criticalChance        Float                 @default(0.05)
  pendingStatPoints     Int                   @default(0)
  bountiesPlaced        Bounty[]              @relation("BountyPlacedBy")
  bountiesTarget        Bounty[]              @relation("BountyTarget")
  party                 Party?                @relation("PartyMembers", fields: [partyId], references: [id])
  user                  User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  statistics            CharacterStatistics?
  dungeonActions        DungeonPlayerAction[]
  dungeonTurns          DungeonTurn[]
  inventory             Inventory[]
  ledParties            Party[]               @relation("PartyLeader")
  partyMembers          PartyMember[]
  reportsAgainst        Report[]              @relation("ReportReported")
  reportsMade           Report[]              @relation("ReportReporter")
  tradeRequestsSent     TradeRequest[]        @relation("TradeRequestFrom")
  tradeRequestsReceived TradeRequest[]        @relation("TradeRequestTo")
  transactions          Transaction[]         @relation("TransactionActor")
  targetTransactions    Transaction[]         @relation("TransactionTarget")

  @@index([isOnline])
  @@index([reputation])
  @@index([gold])
}

model Mission {
  id               String  @id @default(cuid())
  name             String
  description      String
  difficulty       Int
  minLevel         Int     @default(1)
  maxPlayers       Int     @default(5)
  minPlayers       Int     @default(2)
  baseReward       Int
  experienceReward Int     @default(10)
  isActive         Boolean @default(true)
  baseDuration     Int     @default(600)
  minEventInterval Int     @default(30)
  maxEventInterval Int     @default(90)
  environmentType  String  @default("dungeon_corridor")

  // NEW FIELDS
  missionType             String  @default("TIMED") // TIMED, CLEAR, SURVIVAL
  failCondition           String  @default("TIME_OR_DEATH") // TIME_OR_DEATH, DEATH_ONLY, BOSS_DEFEAT
  bossTemplateId          String? // Boss to spawn (for CLEAR missions)
  maxMonstersPerEncounter Int     @default(4) // Max enemies per combat event

  createdAt       DateTime               @default(now())
  updatedAt       DateTime               @updatedAt
  dungeonSessions DungeonSession[]
  allowedEvents   MissionEventTemplate[]
}

model Party {
  id              String           @id @default(cuid())
  name            String?
  isPublic        Boolean          @default(false)
  maxMembers      Int              @default(5)
  status          PartyStatus      @default(FORMING)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  leaderId        String
  characters      Character[]      @relation("PartyMembers")
  dungeonSessions DungeonSession[]
  leader          Character        @relation("PartyLeader", fields: [leaderId], references: [id])
  members         PartyMember[]
}

model PartyMember {
  id          String    @id @default(cuid())
  role        String?
  isReady     Boolean   @default(false)
  joinedAt    DateTime  @default(now())
  partyId     String
  characterId String
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  party       Party     @relation(fields: [partyId], references: [id], onDelete: Cascade)

  @@unique([partyId, characterId])
}

model DungeonSession {
  id                 String             @id @default(cuid())
  status             DungeonStatus      @default(WAITING)
  duration           Int                @default(600)
  missionStartTime   DateTime?
  missionEndTime     DateTime?
  pausedAt           DateTime?
  totalPausedTime    Int                @default(0)
  nextEventSpawnTime DateTime?
  currentEventId     String?
  seed               String?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  missionId          String
  partyId            String?
  events             DungeonEvent[]
  loot               DungeonLoot[]
  mission            Mission            @relation(fields: [missionId], references: [id])
  party              Party?             @relation(fields: [partyId], references: [id])
  statistics         DungeonStatistics?
  turns              DungeonTurn[]

  // Legacy fields (to be removed later)
  currentTurn   Int       @default(0)
  maxTurns      Int       @default(10)
  turnTimeLimit Int       @default(60)
  turnEndsAt    DateTime?
  startedAt     DateTime?
  completedAt   DateTime?
}

model DungeonTurn {
  id          String         @id @default(cuid())
  turnNumber  Int
  action      DungeonAction
  targetId    String?
  itemId      String?
  damage      Int?
  healing     Int?
  isResolved  Boolean        @default(false)
  submittedAt DateTime       @default(now())
  resolvedAt  DateTime?
  sessionId   String
  characterId String
  character   Character      @relation(fields: [characterId], references: [id])
  session     DungeonSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, characterId, turnNumber])
}

model DungeonLoot {
  id        String         @id @default(cuid())
  itemId    String
  quantity  Int            @default(1)
  claimedBy String?
  claimedAt DateTime?
  createdAt DateTime       @default(now())
  sessionId String
  item      Item           @relation(fields: [itemId], references: [id])
  session   DungeonSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
}

model Item {
  id          String             @id @default(cuid())
  name        String             @unique
  description String
  type        ItemType
  rarity      ItemRarity         @default(COMMON)
  value       Int
  attack      Int?
  defense     Int?
  healing     Int?
  isTradeable Boolean            @default(true)
  isStackable Boolean            @default(false)
  maxStack    Int                @default(1)
  createdAt   DateTime           @default(now())
  dungeonLoot DungeonLoot[]
  inventory   Inventory[]
  Transaction Transaction[]
  monsterLoot MonsterLootTable[]
}

model Inventory {
  id          String    @id @default(cuid())
  quantity    Int       @default(1)
  equipped    Boolean   @default(false)
  createdAt   DateTime  @default(now())
  characterId String
  itemId      String
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  item        Item      @relation(fields: [itemId], references: [id])

  @@unique([characterId, itemId])
}

model Transaction {
  id           String          @id @default(cuid())
  type         TransactionType
  amount       Int?
  description  String
  metadata     Json?
  isSuccessful Boolean         @default(true)
  createdAt    DateTime        @default(now())
  actorId      String
  targetId     String?
  itemId       String?
  actor        Character       @relation("TransactionActor", fields: [actorId], references: [id])
  item         Item?           @relation(fields: [itemId], references: [id])
  target       Character?      @relation("TransactionTarget", fields: [targetId], references: [id])

  @@index([actorId])
  @@index([targetId])
  @@index([type])
  @@index([createdAt])
}

model TradeRequest {
  id              String      @id @default(cuid())
  status          TradeStatus @default(PENDING)
  offeredItems    Json
  offeredGold     Int         @default(0)
  requestedItems  Json
  requestedGold   Int         @default(0)
  message         String?
  createdAt       DateTime    @default(now())
  acceptedAt      DateTime?
  completedAt     DateTime?
  fromCharacterId String
  toCharacterId   String
  fromCharacter   Character   @relation("TradeRequestFrom", fields: [fromCharacterId], references: [id])
  toCharacter     Character   @relation("TradeRequestTo", fields: [toCharacterId], references: [id])

  @@index([fromCharacterId])
  @@index([toCharacterId])
  @@index([status])
}

model Bounty {
  id                String       @id @default(cuid())
  amount            Int
  reason            String?
  status            BountyStatus @default(ACTIVE)
  createdAt         DateTime     @default(now())
  claimedAt         DateTime?
  claimedBy         String?
  placedBy          String
  targetId          String
  placedByCharacter Character    @relation("BountyPlacedBy", fields: [placedBy], references: [id])
  targetCharacter   Character    @relation("BountyTarget", fields: [targetId], references: [id])

  @@index([status])
  @@index([amount])
}

model Report {
  id          String       @id @default(cuid())
  reason      ReportReason
  description String
  status      ReportStatus @default(PENDING)
  createdAt   DateTime     @default(now())
  resolvedAt  DateTime?
  resolvedBy  String?
  reporterId  String
  reportedId  String
  reported    Character    @relation("ReportReported", fields: [reportedId], references: [id])
  reporter    Character    @relation("ReportReporter", fields: [reporterId], references: [id])

  @@index([status])
  @@index([reporterId])
  @@index([reportedId])
}

model DungeonStatistics {
  id               String         @id @default(cuid())
  sessionId        String         @unique
  totalEvents      Int            @default(0)
  completedEvents  Int            @default(0)
  failedEvents     Int            @default(0)
  totalTimeSpent   Int            @default(0)
  enemiesDefeated  Int            @default(0)
  damageDealt      Int            @default(0)
  damageTaken      Int            @default(0)
  timesFled        Int            @default(0)
  goldEarned       Int            @default(0)
  itemsFound       Int            @default(0)
  chestsOpened     Int            @default(0)
  experienceGained Int            @default(0)
  levelsGained     Int            @default(0)
  combatEvents     Int            @default(0)
  treasureEvents   Int            @default(0)
  trapEvents       Int            @default(0)
  puzzleEvents     Int            @default(0)
  choiceEvents     Int            @default(0)
  restEvents       Int            @default(0)
  bossEvents       Int            @default(0)
  averageEventTime Int            @default(0)
  successRate      Float          @default(0)
  efficiency       Float          @default(0)
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  session          DungeonSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
}

model CharacterStatistics {
  id                     String    @id @default(cuid())
  characterId            String    @unique
  totalDungeonsCompleted Int       @default(0)
  totalDungeonsFailed    Int       @default(0)
  totalTimeSpent         Int       @default(0)
  totalGoldEarned        Int       @default(0)
  totalExperienceGained  Int       @default(0)
  totalLevelsGained      Int       @default(0)
  totalEnemiesDefeated   Int       @default(0)
  totalDamageDealt       Int       @default(0)
  totalDamageTaken       Int       @default(0)
  totalTimesFled         Int       @default(0)
  totalItemsFound        Int       @default(0)
  totalChestsOpened      Int       @default(0)
  totalItemsUsed         Int       @default(0)
  averageDungeonTime     Int       @default(0)
  successRate            Float     @default(0)
  averageGoldPerDungeon  Int       @default(0)
  averageXPPerDungeon    Int       @default(0)
  longestDungeonTime     Int       @default(0)
  mostGoldInDungeon      Int       @default(0)
  mostXPInDungeon        Int       @default(0)
  mostEnemiesInDungeon   Int       @default(0)
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  character              Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
}

model EventTemplate {
  id               String                 @id @default(cuid())
  type             EventType
  name             String
  description      String
  difficulty       Int
  minigameType     MinigameType?
  config           Json
  outcomes         Json
  createdAt        DateTime               @default(now())
  dungeonEvents    DungeonEvent[]
  missionTemplates MissionEventTemplate[]
}

model MissionEventTemplate {
  id              String   @id @default(cuid())
  missionId       String
  eventTemplateId String
  weight          Int      @default(1) // For weighted random selection
  createdAt       DateTime @default(now())

  mission       Mission       @relation(fields: [missionId], references: [id], onDelete: Cascade)
  eventTemplate EventTemplate @relation(fields: [eventTemplateId], references: [id], onDelete: Cascade)

  @@unique([missionId, eventTemplateId])
  @@index([missionId])
}

model DungeonEvent {
  id            String                @id @default(cuid())
  sessionId     String
  templateId    String?
  eventNumber   Int
  parentEventId String?
  status        EventStatus           @default(PENDING)
  eventData     Json
  results       Json?
  startsAt      DateTime?
  completedAt   DateTime?
  createdAt     DateTime              @default(now())
  parentEvent   DungeonEvent?         @relation("EventBranches", fields: [parentEventId], references: [id])
  childEvents   DungeonEvent[]        @relation("EventBranches")
  session       DungeonSession        @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  template      EventTemplate?        @relation(fields: [templateId], references: [id])
  playerActions DungeonPlayerAction[]

  @@index([sessionId, eventNumber])
  @@index([parentEventId])
}

model DungeonPlayerAction {
  id          String       @id @default(cuid())
  eventId     String
  characterId String
  actionType  String
  actionData  Json
  result      Json?
  submittedAt DateTime     @default(now())
  character   Character    @relation(fields: [characterId], references: [id])
  event       DungeonEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, characterId])
  @@index([characterId])
}

model MonsterTemplate {
  id          String             @id @default(cuid())
  name        String             @unique
  type        MonsterType
  baseHealth  Int
  baseAttack  Int
  baseDefense Int
  attackSpeed Float              @default(1.0)
  canBeElite  Boolean            @default(true)
  abilities   Json?
  rarity      MonsterRarity      @default(COMMON)
  description String?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  lootTable   MonsterLootTable[]
}

model MonsterLootTable {
  id                String          @id @default(cuid())
  monsterTemplate   MonsterTemplate @relation(fields: [monsterTemplateId], references: [id], onDelete: Cascade)
  monsterTemplateId String
  item              Item            @relation(fields: [itemId], references: [id])
  itemId            String
  dropChance        Float // 0.0 to 1.0 (e.g., 0.15 = 15%)
  minQuantity       Int             @default(1)
  maxQuantity       Int             @default(1)
  rarityModifier    Float           @default(1.0) // Multiplier for ELITE/RARE/BOSS
  createdAt         DateTime        @default(now())

  @@unique([monsterTemplateId, itemId])
}

enum PartyStatus {
  FORMING
  READY
  IN_DUNGEON
  COMPLETED
  DISBANDED
}

enum DungeonStatus {
  WAITING
  ACTIVE
  COMPLETED
  FAILED
  ABANDONED
}

enum DungeonAction {
  ATTACK
  DEFEND
  USE_ITEM
  FLEE
  BETRAY
  WAIT
}

enum ItemType {
  WEAPON
  ARMOR
  CONSUMABLE
  MISC
}

enum ItemRarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
}

enum TransactionType {
  TRADE
  THEFT
  KILL
  MISSION_REWARD
  SHOP_PURCHASE
  SHOP_SALE
  GIFT
  BOUNTY_PAYMENT
  BOUNTY_PLACED
  BOUNTY_CLAIMED
  DUNGEON_LOOT
}

enum TradeStatus {
  PENDING
  ACCEPTED
  REJECTED
  COMPLETED
  CANCELLED
}

enum BountyStatus {
  ACTIVE
  CLAIMED
  EXPIRED
  CANCELLED
}

enum ReportReason {
  CHEATING
  HARASSMENT
  EXPLOIT
  OTHER
}

enum ReportStatus {
  PENDING
  INVESTIGATING
  RESOLVED
  DISMISSED
}

enum EventType {
  COMBAT
  TREASURE
  TRAP
  PUZZLE
  CHOICE
  REST
  BETRAYAL_OPPORTUNITY
  NPC_ENCOUNTER
  ENVIRONMENTAL_HAZARD
}

enum MinigameType {
  JUMPING_GAPS
  CLOSING_WALLS
  LOCK_PICKING
  RIDDLE
  QUICK_TIME
  NONE
  COMBAT_CLICKER
}

enum EventStatus {
  PENDING
  ACTIVE
  WAITING
  RESOLVING
  COMPLETED
  SKIPPED
}

enum MonsterType {
  WARRIOR
  RANGER
  MAGE
  HEALER
  TANK
  BERSERKER
}

enum MonsterRarity {
  COMMON
  ELITE
  RARE
  BOSS
}
